<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>Générateur de matchs JSON (Vanilla JS)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial,
          sans-serif;
        max-width: 980px;
        margin: 40px auto;
        padding: 0 16px;
      }
      fieldset {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
      }
      label {
        display: block;
        margin: 0.5rem 0 0.25rem;
      }
      input,
      select,
      button {
        padding: 0.6rem 0.8rem;
        border: 1px solid #d1d5db;
        border-radius: 10px;
      }
      button {
        cursor: pointer;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      pre {
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        border-radius: 12px;
        overflow: auto;
        min-height: 220px;
      }
      .muted {
        color: #6b7280;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <h1>Générateur de matchs JSON</h1>

    <fieldset>
      <legend>Paramètres</legend>
      <div class="grid">
        <div>
          <label>Équipe hôte (fichier joueurs)</label>
          <select id="hostFile">
            <option value="../data/players-team-ACBobigny.json">
              AC Bobigny
            </option>
            <option value="../data/players-team-charonne.json">Charonne</option>
            <option value="../data/players-team-eppg.json">EPPG</option>
            <option value="../data/players-team-noiseene.json">
              Noisy-le-Sec
            </option>
          </select>
        </div>
        <div>
          <label>Équipe adverse (fichier joueurs)</label>
          <select id="opponentFile">
            <option value="../data/players-team-charonne.json">Charonne</option>
            <option value="../data/players-team-eppg.json">EPPG</option>
            <option value="../data/players-team-noiseene.json">
              Noisy-le-Sec
            </option>
            <option value="../data/players-team-ACBobigny.json">
              AC Bobigny
            </option>
          </select>
        </div>
        <div>
          <label>Division</label>
          <select id="division"></select>
        </div>
        <div>
          <label>Section</label>
          <select id="section"></select>
        </div>
        <div>
          <label>Date du match</label>
          <input id="date" type="date" />
        </div>
        <div>
          <label>Seed (reproductible)</label>
          <input id="seed" type="number" value="12345" />
        </div>
        <div>
          <label>Nombre de matchs</label>
          <input id="matchCount" type="number" value="1" min="1" max="100" />
        </div>
        <div>
          <label>Max actions par skill/joueur</label>
          <input id="maxPerSkill" type="number" value="10" min="0" max="50" />
        </div>
      </div>
      <p class="muted">
        Astuce : change le <em>seed</em> pour varier les résultats tout en
        restant déterministe.
      </p>
    </fieldset>

    <label
      style="
        display: inline-flex;
        gap: 0.5rem;
        align-items: center;
        margin-left: 0.5rem;
      "
    >
      <input type="checkbox" id="zoneFirst" />
      Tirer le skill à partir de la zone
    </label>

    <p>
      <button id="generateBtn">Générer</button>
      <button id="downloadBtn" disabled>Télécharger le .json</button>
    </p>

    <h2>Sortie</h2>
    <pre id="output">Clique sur “Générer”…</pre>

    <script>
      const Z = {
        midClose: [
          "mid-range-close-left-top",
          "mid-range-close-left-middle",
          "mid-range-close-left-bottom",
          "mid-range-close-right-top",
          "mid-range-close-right-middle",
          "mid-range-close-right-bottom",
          "mid-range-close-left-top-e",
          "mid-range-close-left-middle-e",
          "mid-range-close-left-bottom-e",
          "mid-range-close-right-top-e",
          "mid-range-close-right-middle-e",
          "mid-range-close-right-bottom-e",
        ],
        midWide: [
          "mid-range-wide-left-bottom-arc",
          "mid-range-wide-left-top",
          "mid-range-wide-left-middle",
          "mid-range-wide-right-bottom-arc",
          "mid-range-wide-right-top",
          "mid-range-wide-right-middle",
          "mid-range-wide-left-bottom-arc-e",
          "mid-range-wide-left-top-e",
          "mid-range-wide-left-middle-e",
          "mid-range-wide-right-bottom-arc-e",
          "mid-range-wide-right-top-e",
          "mid-range-wide-right-middle-e",
        ],
        three: [
          "three-points-arc",
          "threepoints-range-north-west",
          "threepoints-range-north-east",
          "threepoints-range-south-west",
          "threepoints-range-south-east",
          "threepoints-range-middle-north",
          "threepoints-range-middle-south",
          "threepoints-range-middle",
          "threepoints-range-north-west-e",
          "threepoints-range-north-east-e",
          "threepoints-range-south-west-e",
          "threepoints-range-south-east-e",
          "threepoints-range-middle-north-e",
          "threepoints-range-middle-south-e",
          "threepoints-range-middle-e",
        ],
        ft: ["freethrows"],
      };

      const allowedZonesBySkill = {
        freethrow: [...Z.ft],
        shootwiderange: [...Z.three],
        shootmidrange: [...Z.midClose, ...Z.midWide],

        layup: [...Z.midClose, ...Z.ft],
        dunk: [...Z.midClose, ...Z.ft],
        teardrop: [...Z.midClose, ...Z.ft],
        tipin: [...Z.midClose, ...Z.ft],

        offrebound: [...Z.midClose, ...Z.midWide],
        defrebound: [...Z.midClose, ...Z.midWide],
        block: [...Z.midClose, ...Z.midWide],

        steal: [...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
        assist: [...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
        duelwon: [...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
      };

      function allowedZonesForSkill(skill, zones) {
        const allow = allowedZonesBySkill[skill];
        if (!allow) {
          console.warn("[mapping] skill sans mapping:", skill);
          return [];
        }
        const set = new Set(allow);
        const list = zones.map((z) => z.zone).filter((z) => set.has(z));
        if (list.length === 0) {
          console.error(
            "[mapping] aucune zone autorisée trouvée dans zones.json pour",
            skill,
            "→ aucun event généré pour ce skill"
          );
        }
        return list;
      }

      /* ===== Helpers ===== */
      function emptySkillBag(skills) {
        const o = {};
        skills.forEach((s) => (o[s.skill] = { count: 0 }));
        return o;
      }
      function nextIndex(obj) {
        return String(++obj.count);
      }

      function rng(seed) {
        function m(a) {
          return function () {
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }
        return m(seed >>> 0);
      }
      const pad2 = (n) => String(n).padStart(2, "0");
      function timeStamp(r) {
        const min = Math.floor(r() * 9),
          sec = Math.floor(r() * 60),
          ms = Math.floor(r() * 99);
        return `${pad2(min)}min ${pad2(sec)}sec ${pad2(ms)}`;
      }
      const normalizePlayers = (raw) =>
        raw.map((p) => ({
          id: +p.ID,
          firstname: p.NOM,
          lastname: p.PRENOM,
          number: +p.NUMERO,
        }));

      function teamNameFrom(file) {
        if (file.includes("ACBobigny")) return "AC Bobigny";
        if (file.includes("charonne")) return "Charonne";
        if (file.includes("eppg")) return "EPPG";
        if (file.includes("noiseene")) return "Noisy-le-Sec";
        return "Team";
      }

      async function loadJSON(url) {
        const res = await fetch(url);
        if (!res.ok) throw new Error("Fetch " + url);
        return res.json();
      }
      async function loadSources() {
        const [divisions, sections, skills, zones] = await Promise.all([
          loadJSON("../data/divisions.json"),
          loadJSON("../data/sections.json"),
          loadJSON("../data/skills.json"),
          loadJSON("../data/zones.json"),
        ]);
        return { divisions, sections, skills, zones };
      }

      function generatePlayerZoneFirst(p, skills, zones, r, maxPerSkill) {
        // quotas par skill
        const targets = {};
        let total = 0;
        skills.forEach((s) => {
          const n = Math.floor(r() * (maxPerSkill + 1));
          targets[s.skill] = n;
          total += n;
        });

        const allowedSetBySkill = {};
        skills.forEach((s) => {
          allowedSetBySkill[s.skill] = new Set(
            allowedZonesForSkill(s.skill, zones)
          );
        });

        const out = {
          id: p.id,
          firstname: p.firstname,
          lastname: p.lastname,
          number: p.number,
          ...emptySkillBag(skills),
        };

        const skillsLeft = () => Object.values(targets).some((n) => n > 0);
        let guard = 0;
        while (skillsLeft() && guard++ < total * 8) {
          const z = zones[Math.floor(r() * zones.length)].zone;
          const candidates = Object.keys(targets).filter(
            (sk) => targets[sk] > 0 && allowedSetBySkill[sk].has(z)
          );
          if (!candidates.length) continue;

          const sk = candidates[Math.floor(r() * candidates.length)];
          const idx = nextIndex(out[sk]);
          out[sk][idx] = { time: timeStamp(r), zone: z };
          targets[sk]--;
        }

        Object.entries(targets).forEach(([sk, n]) => {
          if (n <= 0) return;
          const zlist = [...allowedSetBySkill[sk]];
          if (zlist.length === 0) {
            console.warn(
              "[mapping] pas de zones autorisées pour",
              sk,
              "→ events ignorés (count resté à",
              n,
              ")"
            );
            return;
          }
          for (let i = 0; i < n; i++) {
            const z = zlist[Math.floor(r() * zlist.length)];
            const idx = nextIndex(out[sk]);
            out[sk][idx] = { time: timeStamp(r), zone: z };
          }
        });

        return out;
      }

      function generateMatch({
        hostName,
        opponentName,
        division,
        section,
        date,
        hostPlayers,
        skills,
        zones,
        r,
        maxPerSkill,
      }) {
        const meta = {
          team: hostName,
          squad: 2,
          division,
          section,
          game: { host: hostName, opponent: opponentName },
          date,
        };

        const zoneFirst = document.getElementById("zoneFirst")?.checked;
        const players = hostPlayers.map((p) =>
          zoneFirst
            ? generatePlayerZoneFirst(p, skills, zones, r, maxPerSkill)
            : (function playerSkillFirst() {
                const out = {
                  id: p.id,
                  firstname: p.firstname,
                  lastname: p.lastname,
                  number: p.number,
                };
                skills.forEach((s) => {
                  const sk = s.skill;
                  const zlist = allowedZonesForSkill(sk, zones); // mapping strict
                  const count = Math.floor(r() * (maxPerSkill + 1));
                  const obj = { count: 0 };

                  if (zlist.length === 0) {
                    out[sk] = obj;
                    return;
                  }

                  for (let i = 0; i < count; i++) {
                    const idx = String(++obj.count);
                    obj[idx] = {
                      time: timeStamp(r),
                      zone: zlist[Math.floor(r() * zlist.length)],
                    };
                  }
                  out[sk] = obj;
                });
                return out;
              })()
        );

        return [meta, players];
      }

      /* ===== UI ===== */
      (async function init() {
        const { divisions, sections, skills, zones } = await loadSources();

        const divSel = document.getElementById("division");
        divisions.forEach((d) => {
          const o = document.createElement("option");
          o.value = o.textContent = d.division;
          divSel.appendChild(o);
        });

        const secSel = document.getElementById("section");
        sections.forEach((s) => {
          const o = document.createElement("option");
          o.value = o.textContent = s;
          secSel.appendChild(o);
        });

        document.getElementById("date").valueAsNumber = Date.now();

        document
          .getElementById("generateBtn")
          .addEventListener("click", async () => {
            const hostFile = document.getElementById("hostFile").value;
            const oppFile = document.getElementById("opponentFile").value;
            const hostName = teamNameFrom(hostFile);
            const oppName = teamNameFrom(oppFile);
            const division =
              document.getElementById("division").value ||
              divisions[0].division;
            const section =
              document.getElementById("section").value || sections[0];
            const date =
              document.getElementById("date").value ||
              new Date().toISOString().slice(0, 10);
            const seed = Number(document.getElementById("seed").value) || 12345;
            const matchCount = Math.max(
              1,
              Number(document.getElementById("matchCount").value) || 1
            );
            const maxPerSkill = Math.max(
              0,
              Number(document.getElementById("maxPerSkill").value) || 10
            );

            const [hostRaw] = await Promise.all([loadJSON(hostFile)]);
            const hostPlayers = normalizePlayers(hostRaw);

            const r = rng(seed);
            const out = [];
            for (let i = 0; i < matchCount; i++) {
              out.push(
                generateMatch({
                  hostName,
                  opponentName: oppName,
                  division,
                  section,
                  date,
                  hostPlayers,
                  skills,
                  zones,
                  r,
                  maxPerSkill,
                })
              );
            }

            const pretty = JSON.stringify(
              out.length === 1 ? out[0] : out,
              null,
              2
            );
            document.getElementById("output").textContent = pretty;

            const btn = document.getElementById("downloadBtn");
            btn.disabled = false;
            btn.onclick = () => {
              const blob = new Blob([pretty], { type: "application/json" });
              const a = document.createElement("a");
              a.href = URL.createObjectURL(blob);
              a.download = out.length === 1 ? "match.json" : "matches.json";
              a.click();
              URL.revokeObjectURL(a.href);
            };
          });
      })();
    </script>
  </body>
</html>
