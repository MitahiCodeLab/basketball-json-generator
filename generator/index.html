<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>G√©n√©rateur de matchs JSON (Vanilla JS)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial,
          sans-serif;
        max-width: 980px;
        margin: 40px auto;
        padding: 0 16px;
      }
      fieldset {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
      }
      label {
        display: block;
        margin: 0.5rem 0 0.25rem;
      }
      input,
      select,
      button {
        padding: 0.6rem 0.8rem;
        border: 1px solid #d1d5db;
        border-radius: 10px;
      }
      button {
        cursor: pointer;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      pre {
        background: #0f172a;
        color: #e2e8f0;
        padding: 16px;
        border-radius: 12px;
        overflow: auto;
        min-height: 220px;
      }
      .muted {
        color: #6b7280;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <h1>G√©n√©rateur de matchs JSON</h1>

    <fieldset>
      <legend>Param√®tres</legend>
      <div class="grid">
        <div>
          <label>√âquipe h√¥te (fichier joueurs)</label>
          <select id="hostFile">
            <option value="../data/players-team-ACBobigny.json">
              AC Bobigny
            </option>
            <option value="../data/players-team-charonne.json">Charonne</option>
            <option value="../data/players-team-eppg.json">EPPG</option>
            <option value="../data/players-team-noiseene.json">
              Noisy-le-Sec
            </option>
          </select>
        </div>
        <div>
          <label>√âquipe adverse (fichier joueurs)</label>
          <select id="opponentFile">
            <option value="../data/players-team-charonne.json">Charonne</option>
            <option value="../data/players-team-eppg.json">EPPG</option>
            <option value="../data/players-team-noiseene.json">
              Noisy-le-Sec
            </option>
            <option value="../data/players-team-ACBobigny.json">
              AC Bobigny
            </option>
          </select>
        </div>
        <div>
          <label>Division</label>
          <select id="division"></select>
        </div>
        <div>
          <label>Section</label>
          <select id="section"></select>
        </div>
        <div>
          <label>Date du match</label>
          <input id="date" type="date" />
        </div>
        <div>
          <label>Seed (reproductible)</label>
          <input id="seed" type="number" value="12345" />
        </div>
        <div>
          <label>Nombre de matchs</label>
          <input id="matchCount" type="number" value="1" min="1" max="100" />
        </div>
        <div>
          <label>Max actions par skill/joueur</label>
          <input id="maxPerSkill" type="number" value="10" min="0" max="50" />
        </div>
      </div>
      <p class="muted">
        Astuce : change le <em>seed</em> pour varier les r√©sultats tout en
        restant d√©terministe.
      </p>
    </fieldset>

    <label
      style="
        display: inline-flex;
        gap: 0.5rem;
        align-items: center;
        margin-left: 0.5rem;
      "
    >
      <input type="checkbox" id="zoneFirst" />
      Tirer le skill √† partir de la zone
    </label>

    <p>
      <button id="generateBtn">G√©n√©rer</button>
      <button id="downloadBtn" disabled>T√©l√©charger le .json</button>
    </p>

    <h2>Sortie</h2>
    <pre id="output">Clique sur ‚ÄúG√©n√©rer‚Äù‚Ä¶</pre>

    <script>
      /* ===== Dictionnaires de zones ===== */
      const Z = {
        midClose: [
          "mid-range-close-left-top","mid-range-close-left-middle","mid-range-close-left-bottom",
          "mid-range-close-right-top","mid-range-close-right-middle","mid-range-close-right-bottom",
          "mid-range-close-left-top-e","mid-range-close-left-middle-e","mid-range-close-left-bottom-e",
          "mid-range-close-right-top-e","mid-range-close-right-middle-e","mid-range-close-right-bottom-e"
        ],
        midWide: [
          "mid-range-wide-left-bottom-arc","mid-range-wide-left-top","mid-range-wide-left-middle",
          "mid-range-wide-right-bottom-arc","mid-range-wide-right-top","mid-range-wide-right-middle",
          "mid-range-wide-left-bottom-arc-e","mid-range-wide-left-top-e","mid-range-wide-left-middle-e",
          "mid-range-wide-right-bottom-arc-e","mid-range-wide-right-top-e","mid-range-wide-right-middle-e"
        ],
        three: [
          "three-points-arc",
          "threepoints-range-north-west","threepoints-range-north-east",
          "threepoints-range-south-west","threepoints-range-south-east",
          "threepoints-range-middle-north","threepoints-range-middle-south","threepoints-range-middle",
          "threepoints-range-north-west-e","threepoints-range-north-east-e",
          "threepoints-range-south-west-e","threepoints-range-south-east-e",
          "threepoints-range-middle-north-e","threepoints-range-middle-south-e","threepoints-range-middle-e"
        ],
        ft: ["freethrows"],
        // "paint" = zone de peinture (zone unique)
        paint: ["paint"],
        allZones: [
          "freethrows", "three-points-arc", "paint",
          "mid-range-close-left-top","mid-range-close-left-middle","mid-range-close-left-bottom",
          "mid-range-wide-left-bottom-arc","mid-range-wide-left-top","mid-range-wide-left-middle",
          "mid-range-close-right-top","mid-range-close-right-middle","mid-range-close-right-bottom",
          "mid-range-wide-right-bottom-arc","mid-range-wide-right-top","mid-range-wide-right-middle",
          "threepoints-range-north-west","threepoints-range-north-east",
          "threepoints-range-south-west","threepoints-range-south-east",
          "threepoints-range-middle-north","threepoints-range-middle-south","threepoints-range-middle",
          "mid-range-close-left-top-e","mid-range-close-left-middle-e","mid-range-close-left-bottom-e",
          "mid-range-wide-left-bottom-arc-e","mid-range-wide-left-top-e","mid-range-wide-left-middle-e",
          "mid-range-close-right-top-e","mid-range-close-right-middle-e","mid-range-close-right-bottom-e",
          "mid-range-wide-right-bottom-arc-e","mid-range-wide-right-top-e","mid-range-wide-right-middle-e",
          "threepoints-range-north-west-e","threepoints-range-north-east-e",
          "threepoints-range-south-west-e","threepoints-range-south-east-e",
          "threepoints-range-middle-north-e","threepoints-range-middle-south-e","threepoints-range-middle-e"
        ]
      };

      /* ===== Mapping skill ‚Üí zones autoris√©es (selon skills-zones.txt) ===== */
      const allowedZonesBySkill = {
        // Mapping exact selon le fichier skills-zones.txt
        shootmidrange: [
          "mid-range-close-left-top","mid-range-close-left-middle","mid-range-close-left-bottom",
          "mid-range-wide-left-bottom-arc","mid-range-wide-left-top","mid-range-wide-left-middle",
          "mid-range-close-right-top","mid-range-close-right-middle","mid-range-close-right-bottom",
          "mid-range-wide-right-bottom-arc","mid-range-wide-right-top","mid-range-wide-right-middle"
        ],

        shootwiderange: [
          "three-points-arc",
          "threepoints-range-north-west","threepoints-range-north-east",
          "threepoints-range-south-west","threepoints-range-south-east",
          "threepoints-range-middle-north","threepoints-range-middle-south","threepoints-range-middle"
        ],

        freethrow: ["freethrows"],

        // Actions dans le "paint" = zones de peinture selon skills-zones.txt
        layup: [...Z.paint],
        dunk: [...Z.paint],
        teardrop: [...Z.paint],
        tipin: [...Z.paint],
        offrebound: [...Z.paint],
        defrebound: [...Z.paint],
        block: [...Z.paint],

        // Actions globales : paint + freethrows + toutes les zones selon skills-zones.txt
        steal: [...Z.paint, ...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
        assist: [...Z.paint, ...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
        duelwon: [...Z.paint, ...Z.ft, ...Z.midClose, ...Z.midWide, ...Z.three],
      };

      function allowedZonesForSkill(skill, zones) {
        const allow = allowedZonesBySkill[skill];
        if (!allow) {
          console.warn("[mapping] skill sans mapping:", skill);
          return [];
        }
        const set = new Set(allow);
        const list = zones.map((z) => z.zone).filter((z) => set.has(z));
        if (list.length === 0) {
          console.error(
            "[mapping] aucune zone autoris√©e trouv√©e dans zones.json pour",
            skill,
            "‚Üí aucun event g√©n√©r√© pour ce skill"
          );
        }
        return list;
      }

      /* ===== Mini-checker console ===== */
      function checkMappingCompliance(output) {
        console.log('üîç [checker] V√©rification du mapping skill ‚Üí zones...');

        const violations = [];
        const stats = {};

        // Parcours du/des match(s)
        const matches = Array.isArray(output[0]) ? output : [output];

        matches.forEach((match, matchIdx) => {
          const [meta, players] = match;
          console.log(`[checker] Match ${matchIdx + 1}: ${meta.game.host} vs ${meta.game.opponent}`);

          players.forEach((player, playerIdx) => {
            Object.keys(allowedZonesBySkill).forEach(skill => {
              const skillData = player[skill];
              if (!skillData) return;

              const count = skillData.count || 0;
              if (!stats[skill]) stats[skill] = { totalEvents: 0, zones: new Set() };
              stats[skill].totalEvents += count;

              // V√©rification des √©v√©nements
              for (let i = 1; i <= count; i++) {
                const event = skillData[String(i)];
                if (!event) continue;

                const zone = event.zone;
                stats[skill].zones.add(zone);

                const allowedZones = allowedZonesBySkill[skill];
                if (!allowedZones.includes(zone)) {
                  violations.push({
                    match: matchIdx + 1,
                    player: `${player.firstname} ${player.lastname} (#${player.number})`,
                    skill,
                    zone,
                    time: event.time
                  });
                }
              }
            });
          });
        });

        // Affichage des statistiques
        console.log('üìä [checker] Statistiques par skill:');
        console.table(Object.fromEntries(
          Object.entries(stats).map(([skill, data]) => [
            skill,
            {
              events: data.totalEvents,
              zones_distinctes: data.zones.size,
              zones_utilis√©es: Array.from(data.zones).sort().join(', ') || 'aucune'
            }
          ])
        ));

        // Affichage des violations
        if (violations.length === 0) {
          console.log('‚úÖ [checker] Aucune violation d√©tect√©e - mapping respect√© !');
        } else {
          console.error(`‚ùå [checker] ${violations.length} violation(s) d√©tect√©e(s):`);
          console.table(violations);
        }

        return { violations, stats };
      }

      /* ===== Helpers ===== */
      function emptySkillBag(skills) {
        const o = {};
        skills.forEach((s) => (o[s.skill] = { count: 0 }));
        return o;
      }
      function nextIndex(obj) {
        return String(++obj.count);
      }

      function rng(seed) {
        function m(a) {
          return function () {
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }
        return m(seed >>> 0);
      }
      const pad2 = (n) => String(n).padStart(2, "0");
      function timeStamp(r) {
        const min = Math.floor(r() * 9),
          sec = Math.floor(r() * 60),
          ms = Math.floor(r() * 99);
        return `${pad2(min)}min ${pad2(sec)}sec ${pad2(ms)}`;
      }
      const normalizePlayers = (raw) =>
        raw.map((p) => ({
          id: +p.ID,
          firstname: p.NOM,
          lastname: p.PRENOM,
          number: +p.NUMERO,
        }));

      function teamNameFrom(file) {
        if (file.includes("ACBobigny")) return "AC Bobigny";
        if (file.includes("charonne")) return "Charonne";
        if (file.includes("eppg")) return "EPPG";
        if (file.includes("noiseene")) return "Noisy-le-Sec";
        return "Team";
      }

      async function loadJSON(url) {
        const res = await fetch(url);
        if (!res.ok) throw new Error("Fetch " + url);
        return res.json();
      }
      async function loadSources() {
        const [divisions, sections, skills, zones] = await Promise.all([
          loadJSON("../data/divisions.json"),
          loadJSON("../data/sections.json"),
          loadJSON("../data/skills.json"),
          loadJSON("../data/zones.json"),
        ]);
        return { divisions, sections, skills, zones };
      }

      function generatePlayerZoneFirst(p, skills, zones, r, maxPerSkill) {
        // quotas par skill
        const targets = {};
        let total = 0;
        skills.forEach((s) => {
          const n = Math.floor(r() * (maxPerSkill + 1));
          targets[s.skill] = n;
          total += n;
        });

        const allowedSetBySkill = {};
        skills.forEach((s) => {
          allowedSetBySkill[s.skill] = new Set(
            allowedZonesForSkill(s.skill, zones)
          );
        });

        const out = {
          id: p.id,
          firstname: p.firstname,
          lastname: p.lastname,
          number: p.number,
          ...emptySkillBag(skills),
        };

        const skillsLeft = () => Object.values(targets).some((n) => n > 0);
        let guard = 0;
        while (skillsLeft() && guard++ < total * 8) {
          const z = zones[Math.floor(r() * zones.length)].zone;
          const candidates = Object.keys(targets).filter(
            (sk) => targets[sk] > 0 && allowedSetBySkill[sk].has(z)
          );
          if (!candidates.length) continue;

          const sk = candidates[Math.floor(r() * candidates.length)];
          const idx = nextIndex(out[sk]);
          out[sk][idx] = { time: timeStamp(r), zone: z };
          targets[sk]--;
        }

        // Compl√©tion (si quotas restants et aucune zone autoris√©e) : ne rien ajouter (count reste 0)
        Object.entries(targets).forEach(([sk, n]) => {
          if (n <= 0) return;
          const zlist = [...allowedSetBySkill[sk]];
          if (zlist.length === 0) {
            console.warn('[mapping] pas de zones autoris√©es pour', sk, '‚Üí quotas restants ignor√©s');
            return;
          }
          for (let i = 0; i < n; i++) {
            const z = zlist[Math.floor(r()*zlist.length)];
            const idx = nextIndex(out[sk]);
            out[sk][idx] = { time: timeStamp(r), zone: z };
          }
        });

        return out;
      }

      function generateMatch({
        hostName,
        opponentName,
        division,
        section,
        date,
        hostPlayers,
        skills,
        zones,
        r,
        maxPerSkill,
      }) {
        const meta = {
          team: hostName,
          squad: 2,
          division,
          section,
          game: { host: hostName, opponent: opponentName },
          date,
        };

        const zoneFirst = document.getElementById("zoneFirst")?.checked;
        const players = hostPlayers.map((p) =>
          zoneFirst
            ? generatePlayerZoneFirst(p, skills, zones, r, maxPerSkill)
            : (function playerSkillFirst() {
                const out = {
                  id: p.id,
                  firstname: p.firstname,
                  lastname: p.lastname,
                  number: p.number,
                  ...emptySkillBag(skills),
                };
                skills.forEach((s) => {
                  const sk = s.skill;
                  const zlist = allowedZonesForSkill(sk, zones);
                  const count = Math.floor(r() * (maxPerSkill + 1));
                  const obj = { count: 0 };

                  // Si aucune zone autoris√©e ‚Üí 0 event (respect strict du mapping)
                  if (zlist.length === 0) { out[sk] = obj; return; }

                  for (let i = 0; i < count; i++) {
                    const idx = String(++obj.count);
                    obj[idx] = { time: timeStamp(r), zone: zlist[Math.floor(r()*zlist.length)] };
                  }
                  out[sk] = obj;
                });
                return out;
              })()
        );

        return [meta, players];
      }

      /* ===== UI ===== */
      (async function init() {
        const { divisions, sections, skills, zones } = await loadSources();

        const divSel = document.getElementById("division");
        divisions.forEach((d) => {
          const o = document.createElement("option");
          o.value = o.textContent = d.division;
          divSel.appendChild(o);
        });

        const secSel = document.getElementById("section");
        sections.forEach((s) => {
          const o = document.createElement("option");
          o.value = o.textContent = s;
          secSel.appendChild(o);
        });

        document.getElementById("date").valueAsNumber = Date.now();

        document
          .getElementById("generateBtn")
          .addEventListener("click", async () => {
            const hostFile = document.getElementById("hostFile").value;
            const oppFile = document.getElementById("opponentFile").value;
            const hostName = teamNameFrom(hostFile);
            const oppName = teamNameFrom(oppFile);
            const division =
              document.getElementById("division").value ||
              divisions[0].division;
            const section =
              document.getElementById("section").value || sections[0];
            const date =
              document.getElementById("date").value ||
              new Date().toISOString().slice(0, 10);
            const seed = Number(document.getElementById("seed").value) || 12345;
            const matchCount = Math.max(
              1,
              Number(document.getElementById("matchCount").value) || 1
            );
            const maxPerSkill = Math.max(
              0,
              Number(document.getElementById("maxPerSkill").value) || 10
            );

            const [hostRaw] = await Promise.all([loadJSON(hostFile)]);
            const hostPlayers = normalizePlayers(hostRaw);

            const r = rng(seed);
            const out = [];
            for (let i = 0; i < matchCount; i++) {
              out.push(
                generateMatch({
                  hostName,
                  opponentName: oppName,
                  division,
                  section,
                  date,
                  hostPlayers,
                  skills,
                  zones,
                  r,
                  maxPerSkill,
                })
              );
            }

            const pretty = JSON.stringify(
              out.length === 1 ? out[0] : out,
              null,
              2
            );
            document.getElementById("output").textContent = pretty;

            // V√©rification automatique du mapping
            checkMappingCompliance(out.length === 1 ? out[0] : out);

            const btn = document.getElementById("downloadBtn");
            btn.disabled = false;
            btn.onclick = () => {
              const blob = new Blob([pretty], { type: "application/json" });
              const a = document.createElement("a");
              a.href = URL.createObjectURL(blob);
              a.download = out.length === 1 ? "match.json" : "matches.json";
              a.click();
              URL.revokeObjectURL(a.href);
            };
          });
      })();
    </script>
  </body>
</html>
